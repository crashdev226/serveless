#!/usr/bin/env node

'use strict';

var JawsError = require('../lib/jaws-error'),
    Jaws = require('../lib/index.js'),
    program = require('commander'),
    utils = require('../lib/utils'),
    Promise = require('bluebird'),
    minimist = require('minimist'),
    handleExit = utils.handleExit;

var JAWS = new Jaws();

Promise.onPossiblyUnhandledRejection(function(error) {
  throw error;
});

program
    .option('-v, --verbose')
    .version(JAWS._meta.version);

program
    .command('new <type>')
    .allowUnknownOption()
    .description('Make a new "project", "stage", "region", "lambda" or "endpoint"')
    .action(function() {

      // Parse Args
      var args = minimist(process.argv.slice(3));
      var type = args._[0] ? args._[0].toLowerCase() : null;

      if (type == 'project') {

        // New Project
        var CmdNewProject = require('../lib/commands/new_project');
        handleExit(CmdNewProject.run(
            args.name,
            args.stage ? args.stage.toLowerCase() : null,
            args.s3Bucket,
            args.region,
            args.email,
            args.profile,
            args.noCf
        ));

      } else if (type == 'region' || type == 'stage') {

        // New Region/Stage
        var CmdNewStageRegion = require('../lib/commands/new_stage_region');
        handleExit(CmdNewStageRegion.run(
            JAWS,
            type,
            args.stage,
            args.region,
            args.noCf
        ));

      } else {
        console.error('Unsupported type ' + type + '. Must be project|region|stage');
        process.exit(1);
      }
    });

program
    .command('generate')
    .description('Create boilerplate structure for a new lambda or api gateway (or both)')
    .option('-l, --lambda', 'will create the files needed for a lambda')
    .option('-r, --lambda-runtime', 'only nodejs supported')
    .option('-a, --endpoint', 'will create the files needed for an api gateway configuration')
    .option('-b, --both', 'shorthand for -l -a')
    .option('-f, --function-name', 'lambda functionName. Will ensure this is unique across your project.')
    .option('-m, --resource-name', 'parent directory the functionName dir will be created in')

    .action(function(options) {
      if (options.lambda || options.both) {
        options.lambda = true;
      }

      if (options.endpoint || options.both) {
        options.endpoint = true;
      }

      var theCmd = require('../lib/commands/generate');
      handleExit(theCmd.run(
          JAWS, options.lambda, options.endpoint, options.functionName, options.resourceName, options.lambdaRuntime
      ));
    });

program
    .command('install <url>')
    .description('Installs a jaws-module from the specified url into the apprpriate area of your JAWS project.')
    .option('-s, --save', 'Save jaws-module\'s CloudFormation and Swagger Template to your project\'s')
    .action(function(url, options) {
      var theCmd = require('../lib/commands/install');
      handleExit(theCmd.install(JAWS, url, options.save));
    });

program
    .command('tag [type]')
    .description('Tag lambda function or api gateway resource (endpoint) for deployment ' +
    'the next time deploy command is run. Type "lambda" is the default.')
    .option('-u, --untag', 'un-tag lambda|endpoint')
    .option('-m, --multi', 'interactively select multiple')
    .option('-a, --tag-all', 'tag all lambda|endpoint functions in project')
    .option('-l, --list-all', 'list all tagged lambda|endpoint functions in project')
    .option('-n, --untag-all', 'un-tag all lambda|endpoint functions in project')
    .action(function(type, options) {
      type = type || 'lambda';
      type = type.toLowerCase();

      if (-1 == ['endpoint', 'lambda'].indexOf(type)) {
        console.error('Unsupported type ' + type + '. Must be endpoint|lambda');
        process.exit(1);
      }

      var theCmd = require('../lib/commands/tag');
      if (options.listAll) {
        handleExit(theCmd.listAll(JAWS, type).then(function(relPaths) {
          console.log(relPaths);
        }));
      } else if (options.tagAll || options.untagAll) {
        var untag = (options.untagAll) ? true : false;
        handleExit(theCmd.tagAll(JAWS, type, untag));
      } else if (options.multi) {
        handleExit(theCmd.tagMulti(JAWS, type, options.untag));
      } else {  //If not tagging all, you have to be tagging whats in your CWD (null 1st param)
        handleExit(theCmd.tag(type, null, options.untag));
      }
    });

program
    .command('deploy <type> [stage] [region]')
    .description('Deploy a lambda function (type lambda), a REST API (endpoint), or provision AWS resources (resources) for the specified stage.' +
    ' By default will tag and deploy type at cwd')
    .option('-t, --tags', 'Deploy all lambdas tagged as deployable in their jaws.json. Default is to just deploy cwd')
    .option('-e, --all-at-once', 'By default, lambdas are deployed once at a time. This deploys all concurrently')
    .action(function(type, stage, region, options) {

      type = type.toLowerCase();
      switch (type) {
        case 'endpoint':
          var allTagged = (options.tags) ? true : false;
          var theCmd = require('../lib/commands/deploy_endpoint');
          handleExit(theCmd.run(JAWS, stage, region, allTagged));
          break;
        case 'lambda':
          var allTagged = (options.tags) ? true : false,
              allAtOnce = (options.allAtOnce) ? true : false;
          var theCmd = require('../lib/commands/deploy_lambda');
          handleExit(theCmd.run(JAWS, stage, region, allTagged, allAtOnce));
          break;
        default:
          console.error('Unsupported type ' + type + '. Must be endpoint|lambda|resources');
          process.exit(1);
          break;
      }
    });

program
    .command('env <cmd> <stage> [key] [val]')
    .description('Manage env vars for stage. Valid cmds: list,get,set,unset.')
    .usage('get test USERNAME or set test USERNAME blah.')
    .action(function(cmd, stage, key, val) {
      var theCmd = require('../lib/commands/env');

      cmd = cmd.toLowerCase();
      switch (cmd) {
        case 'list':
          handleExit(theCmd.listEnv(JAWS, stage));
          break;
        case 'get':
          if (!key) {
            console.error('Must specify key to set');
            process.exit(1);
          }

          handleExit(theCmd.getEnvKey(JAWS, stage, key));
          break;
        case 'set':
          if (!key || typeof val == 'undefined') {
            console.error('Must specify key and value');
            process.exit(1);
          }

          handleExit(theCmd.setEnvKey(JAWS, stage, key, val));
          break;
        case 'unset':
          if (!key) {
            console.error('Must specify key to unset');
            process.exit(1);
          }

          if (val) {
            console.error('Do not specify val for unset');
            process.exit(1);
          }

          handleExit(theCmd.setEnvKey(JAWS, stage, key));
          break;
        default:
          console.error('Unsupported cmd "' + cmd + '". Must be list|get|set|unset');
          process.exit(1);
          break;
      }
    });

program
    .command('dash')
    .description('Check deployment status and deploy resources for a stage and region')
    .action(function() {
      var theCmd = require('../lib/commands/dash');
      handleExit(theCmd.run(JAWS));
    });

if (process.argv.length == 2) {
  program.outputHelp();
} else {
  program.parse(process.argv);
  if (program.verbose) {
    process.env.JAWS_VERBOSE = true;
  }
}
